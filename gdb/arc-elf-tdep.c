/* Target dependent code for ARC processor family, for GDB, the GNU debugger.

   Copyright 2005 Free Software Foundation, Inc.
   Copyright 2009-2012 Synopsys Inc.

   Contributed by Codito Technologies Pvt. Ltd. (www.codito.com) on behalf of
   Synopsys Inc.

   Authors:
      Soam Vasani          <soam.vasani@codito.com>
      Ramana Radhakrishnan <ramana.radhakrishnan@codito.com>
      Richard Stuckey      <richard.stuckey@arc.com>

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/

/******************************************************************************/
/*                                                                            */
/* Outline:                                                                   */
/*     This module provides support for the ARC processor family's target     */
/*     dependencies which are specific to the arc-elf32 configuration of the  */
/*     ARC gdb.                                                               */
/*                                                                            */
/*                                                                            */
/*  Functionality:                                                            */
/*     This module provides a number of operations:                           */
/*                                                                            */
/*     1) a function which returns the name of a register, given its number   */
/*                                                                            */
/*     2) a function which determines whether a given register belongs to a   */
/*        particular group (e.g. the group of registers which should be saved */
/*        and restored across a function call)                                */
/*                                                                            */
/*     3) a function which prints out registers                               */
/*                                                                            */
/*     4) functions which implement the gdb extended commands                 */
/*                                                                            */
/*        arc-watch-range <start> [<kind>]  for setting a watchpoint range    */
/*        arc-break-range <start> <length>  for setting a breakpoint range    */
/*        arc-fill-memory <start> <length> [<pattern>] for filling memory     */
/*                                                                            */
/* Usage:                                                                     */
/*     The module exports a function _initialize_arc_elf_tdep: the call to   */
/*     this function is generated by the gdb build mechanism, so this function*/
/*     should not be explicitly called.                                       */
/*                                                                            */
/*     This module exports a function arc_elf_initialize which creates the   */
/*     user commands which use those command-implementing functions; it also  */
/*     stores pointers to the other functions in a data structure so that     */
/*     they may be called from outside this module.                           */
/*                                                                            */
/*     Some of the operations provided by this module are registered with gdb */
/*     during initialization; gdb then calls them via function pointers,      */
/*     rather than by name (this allows gdb to handle multiple target         */
/*     architectures):                                                        */
/*                                                                            */
/*          set_gdbarch_XXX (gdbarch, <function>);                            */
/*                                                                            */
/******************************************************************************/

/* system header files */
#include <string.h>

/* gdb header files */
#include "defs.h"
#include "inferior.h"
#include "gdbcmd.h"
#include "regcache.h"
#include "reggroups.h"
#include "observer.h"
#include "objfiles.h"
#include "arch-utils.h"

/* ARC header files */
#include "arc-tdep.h"
#include "arc-aux-registers.h"


/* -------------------------------------------------------------------------- */
/*                               local types                                  */
/* -------------------------------------------------------------------------- */

typedef struct
{
  struct gdbarch *gdbarch;
  struct ui_file *file;
  struct frame_info *frame;
} PrintData;


/* -------------------------------------------------------------------------- */
/*                               local data                                   */
/* -------------------------------------------------------------------------- */

#define ARC_NR_REGS             (int) (arc_core_register_count(gdbarch) + \
                                       arc_aux_register_count (gdbarch))
#define ARC_NR_PSEUDO_REGS      0

#define WATCH_MEMORY_COMMAND        "arc-watch-range"
#define BREAK_MEMORY_COMMAND        "arc-break-range"
#define FILL_MEMORY_COMMAND         "arc-fill-memory"

#define WATCH_MEMORY_COMMAND_USAGE  "Usage: " WATCH_MEMORY_COMMAND  " <START> <LENGTH> [ read | write | access ]\n"
#define BREAK_MEMORY_COMMAND_USAGE  "Usage: " BREAK_MEMORY_COMMAND  " <START> <LENGTH>\n"
#define FILL_MEMORY_COMMAND_USAGE   "Usage: " FILL_MEMORY_COMMAND   " <START> <LENGTH> [ <PATTERN> ]\n"



/* ARC 700 */
/* brk_s instruction */
static const unsigned char breakpoint_instruction[] = { 0xff, 0x7f };


/* N.B. the array size is specified in the declaration so that the compiler
 *      will warn of "excess elements in array initializer" if there is a
 *      mismatch (but not of too few elements, unfortunately!).
 */
static const char *register_names[ARC_MAX_CORE_REGS] = {
  "r0", "r1", "r2", "r3", "r4", "r5", "r6",
  "r7", "r8", "r9", "r10", "r11", "r12", "r13",
  "r14", "r15", "r16", "r17", "r18", "r19", "r20",
  "r21", "r22", "r23", "r24", "r25", "r26",

  "fp",				// r27
  "sp",				// r28
  "ilink1",			// r29
  "ilink2",			// r30
  "blink",			// r31

  /* Extension core registers are 32 .. 59 inclusive. */
  "r32", "r33", "r34", "r35", "r36", "r37", "r38", "r39",
  "r40", "r41", "r42", "r43", "r44", "r45", "r46", "r47", "r48", "r49",
  "r50", "r51", "r52", "r53", "r54", "r55", "r56", "r57", "r58", "r59",

  "lp_count",

  /* 61 is reserved, 62 is not a real register. */
  "r61",
  "r62",

  "pcl"
};


/* -------------------------------------------------------------------------- */
/*                               local macros                                 */
/* -------------------------------------------------------------------------- */

#define PRINT(regnum) \
    default_print_registers_info (gdbarch, file, frame, regnum, all)

#define PRINT_HW(hw_regnum)  PRINT(arc_core_register_gdb_number(hw_regnum))

#define PRINT_BY_NAME(regname)                                               \
{                                                                            \
    struct arc_aux_reg_def* def = arc_find_aux_register_by_name(regname); \
                                                                             \
    if (def)                                                                 \
        PRINT(arc_aux_gdb_register_number(def));                             \
} while (0)


/* -------------------------------------------------------------------------- */
/*                               local functions                              */
/* -------------------------------------------------------------------------- */

static void
create_variant_info (struct gdbarch_tdep *tdep)
{
  tdep->processor_variant_info = xmalloc (sizeof (struct arc_variant_info));
  tdep->processor_variant_info->processor_version = NO_ARCHITECTURE;

  arc_initialize_aux_reg_info (&tdep->processor_variant_info->registers);
}


/*! Identify if a register is in a particular group.
    
    For Save/restore:
     *    all standard core regs, except PCL (PCL is not writable)
     *    those extension core regs which are read/write
     *    aux regs LP_START  .. LP_END (IDENTITY is not writable)
     *    aux regs PC_REGNUM .. STATUS32_L2
     *    aux regs ERET      .. EFA

    @return  1 if the register is in the group, 0 if the register is not in
             the group, -1 if we don't know. */
static int
register_reggroup_p (int regnum, struct reggroup *group)
{
  gdb_assert (regnum >= 0);

  if (arc_is_core_register (regnum))
    {
      /* Two core regs not in any reggroup */
      if ((regnum == ARC_RESERVED_REGNUM) || (regnum == ARC_LIMM_REGNUM))
	{
	  return 0;
	}

      if ((group == save_reggroup || group == restore_reggroup))
	{
	  /*! @todo. We should consider optional extension core registers. */
	  return regnum != ARC_PCL_REGNUM;
	}

      if (group == general_reggroup)
	return 1;
    }
  else
    {
      /* @todo In time this information should be extracted from XML, but for
	 now we hard-code. */

      /* Which regs to save/restore? */
      if ((group == save_reggroup || group == restore_reggroup))
	{
	  switch (regnum)
	    {
	    case ARC_PC_REGNUM:
	    case ARC_STATUS32_REGNUM:
	    case ARC_ECR_REGNUM:
	    case ARC_STATUS32_L1_REGNUM:
	    case ARC_STATUS32_L2_REGNUM:
	    case ARC_ERET_REGNUM:
	    case ARC_ERBTA_REGNUM:
	    case ARC_ERSTATUS_REGNUM:
	    case ARC_LP_START_REGNUM:
	    case ARC_LP_END_REGNUM:
	    case ARC_EFA_REGNUM:

	      return 1;

	    default:

	      return 0;
	    }
	}

      if (group == general_reggroup)
	{
	  return ARC_STATUS32_REGNUM != regnum;
	}

      if (group == system_reggroup)
	{
	  switch (regnum)
	    {
	    case ARC_ECR_REGNUM:
	    case ARC_ICAUSE1_REGNUM:
	    case ARC_ICAUSE2_REGNUM:
	    case ARC_STATUS32_L1_REGNUM:
	    case ARC_STATUS32_L2_REGNUM:
	    case ARC_ERET_REGNUM:
	    case ARC_ERBTA_REGNUM:
	    case ARC_ERSTATUS_REGNUM:
	    case ARC_AUX_IRQ_LV12_REGNUM:
	    case ARC_AUX_IRQ_LEV_REGNUM:
	    case ARC_AUX_IRQ_HINT_REGNUM:
	    case ARC_AUX_IENABLE_REGNUM:
	    case ARC_AUX_ITRIGGER_REGNUM:
	    case ARC_AUX_IRQ_PULSE_CANCEL_REGNUM:
	    case ARC_AUX_IRQ_PENDING_REGNUM:
	    case ARC_EFA_REGNUM:
	    case ARC_BTA_L1_REGNUM:
	    case ARC_BTA_L2_REGNUM:

	      /* @todo Old code also had SEMAPHORE aux register, but that is
		 not in the current programmer's manual. */
	      return  1;

	    default:

	      return 0;
	    }
	}
    }

  /* let the caller sort it out! */
  return -1;
}


/* -------------------------------------------------------------------------- */
/*                        local functions called from gdb                     */
/* -------------------------------------------------------------------------- */

static void
print_one_aux_register (struct arc_aux_reg_def * def, void *data)
{
  if (!arc_aux_is_unused (def))
    {
      PrintData *p = (PrintData *) data;
      int regnum = arc_aux_gdb_register_number (def);

      default_print_registers_info (p->gdbarch, p->file, p->frame, regnum,
				    TRUE);
    }
}


/* mapping from binutils/gcc register number to GDB register number ("regnum")
 *
 * N.B. registers such as ARC_FP_REGNUM, ARC_SP_REGNUM, etc., actually have
 *      different GDB register numbers in the arc-elf32 and arc-linux-uclibc
 *      configurations of the ARC gdb.
 */
static int
arc_elf_binutils_reg_to_regnum (struct gdbarch *gdbarch, int reg)
{
  return arc_core_register_gdb_number ((unsigned int) reg);
}


static void
arc_elf_print_registers_info (struct gdbarch *gdbarch,
			       struct ui_file *file,
			       struct frame_info *frame, int regnum, int all)
{
  if (regnum >= 0)
    PRINT (regnum);
  else
    /* if regnum < 0, print registers */
    {
      /* r32 .. r59 are the extension core registers, r61 and r62 are reserved */

      /* r0 .. r26 */
      for (regnum = 0; regnum <= 26; regnum++)
	PRINT_HW ((unsigned int) regnum);

      PRINT_HW (ARC_FP_REGNUM);	// r27
      PRINT_HW (ARC_SP_REGNUM);	// r28
      PRINT_HW (ARC_ILINK1_REGNUM);	// r29
      PRINT_HW (ARC_ILINK2_REGNUM);	// r30
      PRINT_HW (ARC_BLINK_REGNUM);	// r31
      PRINT_HW (ARC_LP_COUNT_REGNUM);	// r60
      PRINT_HW (ARC_PCL_REGNUM);	// r63

      if (all)
	{
	  PrintData data = { gdbarch, file, frame };

	  arc_all_aux_registers (print_one_aux_register, &data);
	}
      else
	{
	  PRINT_BY_NAME ("LP_START");
	  PRINT_BY_NAME ("LP_END");
	  PRINT_BY_NAME ("STATUS32");
	  PRINT_BY_NAME ("BTA");
	  PRINT_BY_NAME ("EFA");
	  PRINT_BY_NAME ("ERET");
	  PRINT_BY_NAME ("STATUS32_L1");
	  PRINT_BY_NAME ("STATUS32_L2");
	  PRINT_BY_NAME ("ERSTATUS");
	  PRINT_BY_NAME ("PC");
	}
    }
}


/* return the name of the given register */
static const char *
arc_elf_register_name (struct gdbarch *gdbarch, int gdb_regno)
{
  if (gdb_regno >= 0)
    {
      if (arc_is_core_register (gdb_regno))
	{
	  unsigned int hw_num = arc_core_register_number (gdb_regno);

	  if (hw_num < ELEMENTS_IN_ARRAY (register_names))
	    return register_names[hw_num];
	}
      else
	{
	  struct arc_aux_reg_def *def =
	    arc_find_aux_register_by_gdb_number (gdb_regno);

	  /* if it is an aux register */
	  if (def)
	    return arc_aux_register_name (def);
	}
    }

  internal_error (__FILE__, __LINE__, _("Invalid register number: %d"),
		  gdb_regno);
}


/* determine whether the given register is read-only */
static int
arc_elf_cannot_store_register (struct gdbarch *gdbarch, int gdb_regno)
{
  struct arc_aux_reg_def *def =
    arc_find_aux_register_by_gdb_number (gdb_regno);

  /* No warning should be printed.  arc_cannot_store_register being
     called does not imply that someone is actually writing to regnum.  */

  /* if it is an aux register */
  if (def)
    return (arc_aux_register_access (def) == READ_ONLY) ? 1 : 0;

  return 0;
}


/* -------------------------------------------------------------------------- */
/*                               externally visible functions                 */
/* -------------------------------------------------------------------------- */

/*! Function to identify the OSABI to be used.

    Every target variant must define this appropriately. */
enum gdb_osabi
arc_get_osabi (void)
{
  return  GDB_OSABI_UNKNOWN;

}	/* arc_get_osabi () */


/*! Initialize the ELF ABI */
static void
arc_elf_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* todo: Do we really need this. Seems an archaic JTAG thing. */
  /* arc_aux_pc_guard (gdbarch); */

  /* This had some horribly contorted code, which relied on the initialize
     function being called twice, creating a new tdep the first time, and then
     initializing the registers a second time. It's amazing it ever worked! */
  create_variant_info (tdep);
  /* have aux registers been defined for that arch`? */
  if (!arc_aux_regs_defined (gdbarch))
    {
      /* Try to get the definitions of the target's auxiliary registers */
      arc_read_default_aux_registers (gdbarch);
    }

  /* Fill in target-dependent info in ARC-private structure. */

  tdep->is_sigtramp = NULL;
  tdep->sigcontext_addr = NULL;
  tdep->sc_reg_offset = NULL;
  tdep->sc_num_regs = 0;
  tdep->pc_regnum_in_sigcontext = 0;

  tdep->breakpoint_instruction = breakpoint_instruction;
  tdep->breakpoint_size = (unsigned int) sizeof (breakpoint_instruction);

  tdep->register_reggroup_p = register_reggroup_p;
  tdep->lowest_pc = 0;

  /* Pass target-dependent info to gdb. */

  /* ARC_NR_REGS and ARC_NR_PSEUDO_REGS are defined above, but ought to be
     more generally set. */
  set_gdbarch_pc_regnum (gdbarch, arc_aux_pc_number (gdbarch));
  set_gdbarch_num_regs (gdbarch, ARC_NR_REGS);
  set_gdbarch_num_pseudo_regs (gdbarch, ARC_NR_PSEUDO_REGS);
  set_gdbarch_print_registers_info (gdbarch, arc_elf_print_registers_info);
  set_gdbarch_register_name (gdbarch, arc_elf_register_name);
  set_gdbarch_cannot_store_register (gdbarch, arc_elf_cannot_store_register);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, arc_elf_binutils_reg_to_regnum);

}


/*! ELF specific initialization function. */
void
_initialize_arc_elf_tdep (void)
{
  /* register a handler with gdb for the Linux O/S ABI variant for the ARC
   * processor architecture, providing an initialization function;
   *
   * 'bfd_arch_arc' is an enumeration value specifically denoting the ARC
   *                architecture
   */
  gdbarch_register_osabi (bfd_arch_arc, 0,	/* machine (irrelevant) */
			  GDB_OSABI_UNKNOWN, arc_elf_init_abi);

}	/* _initialize_arc_elf_tdep () */
