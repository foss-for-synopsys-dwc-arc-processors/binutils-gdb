/* Target dependent code for ARC processor family, for GDB, the GNU debugger.

   Copyright 2005 Free Software Foundation, Inc.
   Copyright 2009-2012 Synopsys Inc.

   Contributed by Codito Technologies Pvt. Ltd. (www.codito.com) on behalf of
   Synopsys Inc.

   Authors:
      Sameer Dhavale       <sameer.dhavale@codito.com>
      Ramana Radhakrishnan <ramana.radhakrishnan@codito.com>
      Richard Stuckey      <richard.stuckey@arc.com>

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/

/******************************************************************************/
/*                                                                            */
/* Outline:                                                                   */
/*     This module creates an instance of a gdb 'target_ops' structure which  */
/*     contains information and operations for debugging a remote ARC target  */
/*     with JTAG.                                                             */
/*                                                                            */
/*     It also registers a number of ARC-specific commands with gdb.          */
/*                                                                            */
/* Usage:                                                                     */
/*     The module exports a function _initialize_arc_debug: the call to this  */
/*     function is generated by the gdb build mechanism, so this function     */
/*     should not be explicitly called.                                       */
/*                                                                            */
/******************************************************************************/

/* system header files */
#include <assert.h>
#include <signal.h>
#include <byteswap.h>

/* gdb header files */
#include "defs.h"
#include "inferior.h"
#include "gdbcore.h"
#include "regcache.h"
#include "symtab.h"
#include "breakpoint.h"
#include "exceptions.h"
#include "gdbcmd.h"
#include "objfiles.h"
#include "libiberty.h"

/* ARC header files */
#include "config/arc/tm-embed.h"
#include "arc-board.h"
#include "arc-gpio.h"
#include "arc-jtag.h"
#include "arc-tdep.h"
#include "arc-support.h"
#include "arc-jtag-tdep.h"
#include "arc-jtag-ops.h"
#include "arc-jtag-actionpoints.h"
#include "arc-aux-registers.h"
#include "arc-architecture.h"
#include "arc-jtag-fileio.h"


/* -------------------------------------------------------------------------- */
/*                               local data                                   */
/* -------------------------------------------------------------------------- */

#define ARC_CONFIGURATION_COMMAND      "arc-configuration"
#define ARC_RESET_BOARD_COMMAND        "arc-reset-board"
#define ARC_LIST_ACTIONPOINTS_COMMAND  "arc-list-actionpoints"
#define ARC_FSM_DEBUG_COMMAND          "arcjtag-debug-statemachine"
#define ARC_JTAG_RETRY_COMMAND         "arcjtag-retry-count"

#define ARC_CONFIGURATION_COMMAND_USAGE      "Usage: info " ARC_CONFIGURATION_COMMAND     "\n"
#define ARC_RESET_BOARD_COMMAND_USAGE        "Usage: "      ARC_RESET_BOARD_COMMAND       "\n"
#define ARC_LIST_ACTIONPOINTS_COMMAND_USAGE  "Usage: "      ARC_LIST_ACTIONPOINTS_COMMAND "\n"


#define INVALID_REGISTER_NUMBER        (ARC_RegisterNumber) 0xFFFFFFFFU

#define MINIMUM_INSTRUCTION_SIZE       2
#define MOV_SP_INSTRUCTION             0x3f80240a


static struct target_ops arc_debug_ops;

/* For the Ctrl-C signal handler.  */
static void (*old_signal_handler) (int);

static ARC_RegisterNumber lp_start_regnum;
static ARC_RegisterNumber lp_end_regnum;
static ARC_RegisterNumber identity_regnum;
static ARC_RegisterNumber debug_regnum;
static ARC_RegisterNumber pc_regnum;
static ARC_RegisterNumber status32_regnum;

static ARC_RegisterNumber icache_ivic_regnum;
static ARC_RegisterNumber icache_control_regnum;
static ARC_RegisterNumber dcache_ivdc_regnum;
static ARC_RegisterNumber dcache_control_regnum;

static CORE_ADDR stack_pointer_setup_code_operand_address;

/* this flag is used by the Ctrl-C interrupt mechanism: it is set by an
 * interrupt handler and tested by non-interrupt code, so must be declared
 * as volatile to avoid possible optimisation problems
 */
static volatile Boolean interrupt_processor;


/* -------------------------------------------------------------------------- */
/*                               external data                                */
/* -------------------------------------------------------------------------- */

/* this declaration should be in the file breakpoint.h (a gdb core file) */
extern struct breakpoint *breakpoint_chain;


/* -------------------------------------------------------------------------- */
/*                               local macros                                 */
/* -------------------------------------------------------------------------- */

#define TARGET_ENDIAN(word)   ((target_is_big_endian) ? __bswap_32(word) : (word))

#define IS_ARC700       (arc_get_architecture(identity_regnum) == ARC700)
#define IS_ARC600       (arc_get_architecture(identity_regnum) == ARC600)


#define MK_OPERAND(x)    (ARC_Word) ((((x) & 0xffff0000) >> 16) | \
                                     (((x) & 0x0000ffff) << 16)) 


/* -------------------------------------------------------------------------- */
/*                               forward declarations                         */
/* -------------------------------------------------------------------------- */

static void interrupted_twice (int signo);
static void restore_stack_top_address (void);


/* -------------------------------------------------------------------------- */
/*                               local functions                              */
/* -------------------------------------------------------------------------- */

/* -------------------------------------------------------------------------- */
/* 1)                functions for reading/writing registers                  */
/* -------------------------------------------------------------------------- */

static void core_warning(char*              format,
                         ARC_RegisterNumber hw_regno,
                         int                gdb_regno)
{
    warning(format,
            IS_EXTENSION_CORE_REGISTER(hw_regno) ? "extension " : "",
            gdbarch_register_name(current_gdbarch, gdb_regno));
}


static void aux_warning(char*              format,
                        ARC_RegisterNumber hw_regno)
{
    warning(format, arc_aux_register_name_of(hw_regno), hw_regno);
}


static void
debug_fetch_one_register (struct regcache*   regcache,
                          ARC_RegisterNumber hw_regno,
                          int                gdb_regno)
{
    ARC_RegisterContents contents;
    Boolean              register_read = FALSE;

    ENTERMSG;

    gdb_assert(gdb_regno >= 0);

    /* N.B. do not give a warning message if the register is write-only, as gdb
     *      may be reading all registers, and it is best to quietly ignore the
     *      ones that can not be read!
     */
    if (arc_is_core_register(gdb_regno))
    {
        if (arc_core_register_access(hw_regno) != WRITE_ONLY)
            register_read = arc_read_jtag_core_register(hw_regno, &contents, TRUE);
    }
    else
    {
        ARC_AuxRegisterDefinition* def = arc_find_aux_register_by_hw_number(hw_regno);

        if (arc_aux_register_access(def) != WRITE_ONLY)
            register_read = arc_read_jtag_aux_register (hw_regno, &contents, TRUE);
    }

    if (register_read)
        regcache_raw_supply (regcache, (int) gdb_regno, &contents);

    LEAVEMSG;
}


/* this function is passed to the arc_all_aux_registers iterator */
static void
debug_fetch_reg (ARC_AuxRegisterDefinition* def, void* data)
{
    debug_fetch_one_register((struct regcache*) data,
                             arc_aux_hw_register_number (def),
                             arc_aux_gdb_register_number(def));
}


static void
debug_store_one_register (struct regcache*   regcache,
                          ARC_RegisterNumber hw_regno,
                          int                gdb_regno)
{
    ARC_RegisterContents contents;

    ENTERMSG;

    gdb_assert(gdb_regno >= 0);

    regcache_raw_collect(regcache, gdb_regno, &contents);

    if (arc_is_core_register(gdb_regno))
    {
        if (arc_core_register_access(hw_regno) == READ_ONLY)
            core_warning(_("%score register %s is read-only"), hw_regno, gdb_regno);
        else
            (void) arc_write_jtag_core_register(hw_regno, contents, TRUE);
    }
    else
    {
        ARC_AuxRegisterDefinition* def = arc_find_aux_register_by_hw_number(hw_regno);

        if (arc_aux_register_access(def) == READ_ONLY)
            aux_warning(_("auxiliary register %s (0x%x) is read-only"), hw_regno);
        else
            (void) arc_write_jtag_aux_register (hw_regno, contents, TRUE);
    }

    LEAVEMSG;
}


/* this function is passed to the arc_all_aux_registers iterator */
static void
debug_store_reg (ARC_AuxRegisterDefinition* def, void* data)
{
    debug_store_one_register ((struct regcache*) data,
                              arc_aux_hw_register_number (def),
                              arc_aux_gdb_register_number(def));
}


static ARC_RegisterNumber get_hw_regnum_mapping (int gdb_regno)
{
    ARC_AuxRegisterDefinition* def;

    if (arc_is_core_register(gdb_regno))
        return arc_core_register_number(gdb_regno);

    def = arc_find_aux_register_by_gdb_number(gdb_regno);

    if (def)
        return arc_aux_hw_register_number(def);

    /* not found */
    return INVALID_REGISTER_NUMBER;
}


/* Set UB bit in the DEBUG register. It allows brk_s instruction to work in User mode.  */
static Boolean
set_debug_user_bit (ARC_RegisterContents extra_bits)
{
    /* the DEBUG User bit exists only in the ARC700 */
    if (IS_ARC700)
        extra_bits |= DEBUG_USER;

    if (extra_bits != 0)
    {
        ARC_RegisterContents debug;

        if (arc_read_jtag_aux_register(debug_regnum, &debug, TRUE))
        {
            /* set UB = 1 */
            ARC_RegisterContents new_debug = debug | extra_bits;

            /* do the write only if it will change the register contents */
            if (new_debug != debug)
                return arc_write_jtag_aux_register(debug_regnum, new_debug, TRUE);
        }
        else
            return FALSE;
    }

    return TRUE;
}


/* -------------------------------------------------------------------------- */
/* 2)               functions for processor cache management                  */
/* -------------------------------------------------------------------------- */

static void
invalidate_caches (void)
{
    /* N.B. when invalidating the data caches, we must first set the DC_CTRL.IM
     *      bit to 1 to ensure that any "dirty" lines in the cache get flushed
     *      to main memory
     */
    (void) arc_write_jtag_aux_register(dcache_control_regnum, DC_CTRL_IM, TRUE);
    (void) arc_write_jtag_aux_register(icache_ivic_regnum,    IC_IVIC_IV, TRUE);
    (void) arc_write_jtag_aux_register(dcache_ivdc_regnum,    DC_IVDC_IV, TRUE);
}


static void
disable_caches (void)
{
    (void) arc_write_jtag_aux_register(icache_control_regnum, IC_CTRL_DC, TRUE);
    (void) arc_write_jtag_aux_register(dcache_control_regnum, DC_CTRL_DC, TRUE);
}


/* -------------------------------------------------------------------------- */
/* 3)                   functions for JTAG interface management               */
/* -------------------------------------------------------------------------- */

static Boolean open_JTAG_interface(int from_tty)
{
    /* we do not yet know what processor is on the target */
    ARC_processor = NO_ARCHITECTURE;

    /* This is somewhat inelegant, but commands read from scripts in the gdb
     * testsuite are regarded as though they were being input interactively
     * (i.e. from_tty is 1), and interactive queries may be made (such as
     * asking the user whether the program currently being debugged should be
     * killed first) - and these queries hang the tests!
     *
     * So, if the environment variable is set, assume that the gdb test suite is
     * being run, so that no such queries will be made.
     *
     * It is not possible to make this check in the top-level command handler
     * loop, as the output from some other commands (e.g. 'file') depend on the
     * from_tty parameter passed to them, and the gdb test scripts expect to get
     * the interactive version of the output!
     */
    target_preopen(from_tty && (getenv("ARC_GDB_TEST") == NULL));

    gdb_assert(arc_jtag_ops.open != NULL);

    return arc_jtag_ops.open();
}


static void close_JTAG_interface(Boolean resume)
{
    /* if we have a target connected */
    if (arc_jtag_ops.status == JTAG_OPENED)
    {
        /* do this while the target is halted */
        restore_stack_top_address();

        arc_set_jtag_interception(INTERCEPTION_OFF);

        /* let the target continue */
        if (resume)
            target_resume (inferior_ptid, 0, 0);

        /* and close the connection */
        arc_jtag_ops.close();
        current_target.to_has_execution = 0;

        ARC_processor = NO_ARCHITECTURE;
    }
}


/* -------------------------------------------------------------------------- */
/* 4)                functions for starting/stopping the processor            */
/* -------------------------------------------------------------------------- */

/* start the processor by clearing the 'H' bit in the STATUS32 register*/
static void start_processor(void)
{
    ARC_RegisterContents status32;

    if (!arc_read_jtag_aux_register (status32_regnum, &status32,                  FALSE) ||
        !arc_write_jtag_aux_register(status32_regnum,  status32 & ~STATUS32_HALT, FALSE))
        warning(_("can not clear Halt bit in STATUS32 auxiliary register - can not start processor"));
}


/* stop the processor by setting the 'FH' bit in the DEBUG register*/
static void stop_processor(void)
{
    if (!arc_write_jtag_aux_register(debug_regnum, DEBUG_FORCE_HALT, FALSE))
        warning(_("can not set Force Halt bit in DEBUG auxiliary register - can not halt processor"));
}


static Boolean halt_processor_on_connection(void)
{
    Boolean      warn_on_read_failure = TRUE;
    Boolean      inform_running       = TRUE;
    Boolean      halt_attempted       = FALSE;
    unsigned int tries                = 0;

    /* try to ensure that the processor is halted
     *
     * N.B. unfortunately, if the gpio driver module has been installed on the
     *      host machine, the gpio read/write operations appear to work even if
     *      the host is NOT physically connected to the JTAG target!
     *
     *      There does not appear to be any way of detecting that situation -
     *      all we can do is bale out if we have not succeded in reading the
     *      STATUS32 register after the required number of retries!
     */
    do
    {
        ARC_RegisterContents status = 0;

        /* read the status32 register here to check if the halt bit is set */
        if (arc_read_jtag_aux_register(status32_regnum, &status, warn_on_read_failure))
        {
            if (status & STATUS32_HALT)
            {
                // success!
                printf_filtered(_("Processor is halted.\n"));
                return TRUE;
            }

            if (inform_running)
            {
                /* we inform the user that the processor is running  only once
                 * (to avoid swamping the user!)
                 */
                printf_filtered(_("Processor is running. Trying to halt it...\n"));
                inform_running = FALSE;
            }

            stop_processor();
            halt_attempted = TRUE;
        }
        else
        {
            /* we give a warning only on the first read failure (otherwise the
             * user can get swamped with warnings!)
             */
            warn_on_read_failure = FALSE;
        }

        /* just in case we actually did fail to read/write the port */
        if (gpio_port_error)
        {
            warning(_("error in accessing parallel port via "
                      GPIO_DEVICE 
                      " - check connection to target board."));
            return FALSE;
        }
    }
    while (++tries <= arc_jtag_ops.retry_count);

    if (halt_attempted)
        printf_filtered(_("Can not halt processor!\n"));
    else
        printf_filtered(_("Can not connect to processor!\n"));

    return FALSE;
}


static Boolean processor_is_halted(ARC_RegisterContents      debug,
                                   struct target_waitstatus* status)
{
    /* test BH bit of DEBUG register */
    if (debug & DEBUG_BH)
    {
        /* a s/w breakpoint instruction was executed */

        /* if the breakpoint is on an intercepted function entrypoint */
        switch (arc_check_interception_breakpoint(pc_regnum, &status->value.integer))
        {
            case INTERCEPTION_RESUME:
                /* if the user has typed a Ctrl-C since target execution was
                 * last started
                 */
                if (interrupt_processor)
                {
                    /* the interception is complete, so honour the interrupt
                     * request by making it appear that the target was stopped
                     * by a SIGINT signal; the PC has been set to the return
                     * address of the intercepted function, so it will look to
                     * the user as though the program was interrupted at that
                     * point
                     */
                    status->kind      = TARGET_WAITKIND_STOPPED;
                    status->value.sig = TARGET_SIGNAL_INT;
                }
                else
                {
                    DEBUG("*** resuming execution\n");
                    start_processor();
                    /* this is the only case in which we return FALSE */
                    return FALSE;
                }
                break;

            case INTERCEPTION_HALT:
                /* some other breakpoint has triggered */
                status->kind      = TARGET_WAITKIND_STOPPED;
                status->value.sig = TARGET_SIGNAL_TRAP;
                break;

            case INTERCEPTION_EXIT:
                /* the program called the 'exit' routine (its exit status has
                 * been read by the interception mechanism and returned to us in
                 * status->value.integer)
                 */
                status->kind = TARGET_WAITKIND_EXITED;
                break;
        }
    }
    /* test SH bit of DEBUG register */
    else if (debug & DEBUG_SH)
    {
        /* if the DEBUG.SH ("self halt") bit is set, we stopped because of the
         * flag instruction, which is used by programs to exit
         */
        ARC_RegisterContents exitcode;

        status->kind = TARGET_WAITKIND_EXITED;

        /* get the exit code of the program (held in R0) */
        if (arc_read_jtag_core_register(0, &exitcode, TRUE))
            status->value.integer = (int) exitcode;
        else
        {
            warning(_("assuming exit code = 0"));
            status->value.integer = 0;
        }
    }
    else
    {
        /* we stopped for some other reason: if the user had tried to interrupt
         * with a Ctrl-C, return the event as a SIGINT, otherwise as a SIGTRAP
         * (and let gdb work out what happened)
         */
        status->kind      = TARGET_WAITKIND_STOPPED;
        status->value.sig = (interrupt_processor) ? TARGET_SIGNAL_INT
                                                  : TARGET_SIGNAL_TRAP;
    }

    return TRUE;
}


static void wait_for_processor_to_halt(struct target_waitstatus* status)
{
    ARC_RegisterContents debug;

    /* wait until processor has *really* halted */
    do
    {
        /* polling wait until HALT bit is set in STATUS32 register */
        while (TRUE)
        {
            ARC_RegisterContents status32;

            /* if the user has typed a Ctrl-C since target execution was last
             * started, try to force the processor to halt; it does not matter
             * if we do not succeed, as we will simply try again on the next
             * iteration of the loop
             */
            if (interrupt_processor)
                stop_processor();

            /* now try to read the STATUS32 register, and check whether its H
             * bit is set, indicating that the processor has halted; again, it
             * does not matter if we do not succeed, as we will simply try again
             * on the next iteration of the loop
             */
            if (arc_read_jtag_aux_register(status32_regnum, &status32, TRUE))
            {
#if 0
                ARC_RegisterContents PC;

                printf_filtered("STATUS32: %08X\n", status32);

                if (arc_read_jtag_aux_register(pc_regnum, &PC, TRUE))
                    printf_filtered("PC: %08X\n", PC);
#endif

                if (status32 & STATUS32_HALT)
                {
                     DEBUG("halted: STATUS32 = %08X\n", status32);
                     break;
                }
            }
        }

        /* polling wait for any delayed load to complete */
        while (TRUE)
        {
            if (arc_read_jtag_aux_register(debug_regnum, &debug, TRUE))
            {
                if (!(debug & DEBUG_LOAD_PENDING))
                    break;
            }
        }

        /* the processor is now halted in a reliable state */

        DEBUG("wait: DEBUG = %08X\n", debug);

        /* but it might need to be re-started... */

    } while (!processor_is_halted(debug, status));

    DEBUG("processor has halted");
}


/* -------------------------------------------------------------------------- */
/* 5)            functions for setting up target program arguments            */
/* -------------------------------------------------------------------------- */

static CORE_ADDR find_label(const char* label)
{
    struct minimal_symbol* msymbol = lookup_minimal_symbol(label, NULL, symfile_objfile);
    CORE_ADDR              address = 0;

    if (msymbol != NULL)
        address = SYMBOL_VALUE_ADDRESS (msymbol);

    DEBUG("%s = %x\n", label, (unsigned int) address);

    return address;
}


static Boolean write_word(CORE_ADDR* address, ARC_Word word, Boolean target_is_big_endian)
{
    if (arc_jtag_ops.memory_write_word((ARC_Address) *address,
                                       TARGET_ENDIAN(word)) == BYTES_IN_WORD)
    {
        *address += BYTES_IN_WORD;
       return TRUE;
    }

    return FALSE;
}


static Boolean find_stack_top_setup_code(CORE_ADDR stack_top)
{
    /* try to find the start address in the target program */
    CORE_ADDR code_start = find_label("__start");

    if (code_start != 0)
    {
        ARC_Address code = (ARC_Address) code_start;
        ARC_Word    set_sp_insn[2];
        ARC_Byte    buffer[16 * BYTES_IN_WORD];

        DEBUG("setting up arguments: stack_top = %x, code_start = %x\n",
              (unsigned int) stack_top, (unsigned int) code_start);

        set_sp_insn[0] = MOV_SP_INSTRUCTION;
        set_sp_insn[1] = MK_OPERAND(stack_top);

        /* scan through the start code of the program, looking for the code that
         * sets up the program's stack pointer; we recognize this as a 32-bit
         * 'mov sp' instruction followed by a 32-bit operand which is the
         * address of the stack top (which we obtained from the executable file)
         */

        while (TRUE)
        {
            unsigned int bytes = arc_jtag_ops.memory_read_chunk(code, buffer, (unsigned int) sizeof(buffer));

            if (bytes == (unsigned int) sizeof(buffer))
            {
                size_t offset = 0;

                while (offset <= sizeof(buffer) - sizeof(set_sp_insn))
                {
                    if (memcmp(buffer + offset, set_sp_insn, sizeof(set_sp_insn)) == 0)
                    {
                        stack_pointer_setup_code_operand_address = code + (CORE_ADDR) offset + BYTES_IN_WORD;

                        DEBUG("found 'mov sp, <stacktop>' instruction operand at address 0x%x\n",
                              (unsigned int) stack_pointer_setup_code_operand_address);
                        return TRUE;
                    }

                    offset += MINIMUM_INSTRUCTION_SIZE;
                }
            }
            else
            {
                warning(_("can not find read target program start code"));
                break;
            }

            code += (ARC_Address) (sizeof(buffer) - sizeof(set_sp_insn));

            /* if we haven't found it in the first 100 bytes... */
            if (code - (ARC_Address) code_start > 100)
            {
                warning(_("can not find 'mov sp, <stacktop>' instruction in start code"));
                break;
            }
        }
    }

    return FALSE;
}


static Boolean set_stack_top(CORE_ADDR old_stack_top, CORE_ADDR new_stack_top)
{
    ARC_Word operand = MK_OPERAND(new_stack_top);

    /* if we do not yet know the address in the program code at which the
     * program's stack pointer is set up
     */
    if (stack_pointer_setup_code_operand_address == 0)
    {
        /* try to find it */
        if (!find_stack_top_setup_code(old_stack_top))
            return FALSE;
    }

    /* N.B. can not use jtag_memory_write_word operation here as the operand
     *      address might not be word-aligned!
     */
    return (arc_jtag_ops.memory_write_chunk
               ((ARC_Address) stack_pointer_setup_code_operand_address,
                (ARC_Byte*)   &operand,
                BYTES_IN_WORD) == BYTES_IN_WORD);
}


/* store the program's arguments on the stack
 *
 * E.g. if we are passing 4 arguments to main, we must place them on the stack
 *      in the layout:
 *
 *             . 
 *             . 
 *          stack[top + A3] <== <arg_3>
 *             . 
 *             . 
 *          stack[top + A2] <== <arg_2>
 *             . 
 *             . 
 *          stack[top + A1] <== <arg_1>
 *             . 
 *             . 
 *          stack[top + A0] <== <arg_0>
 *          stack[top + 24] <== 0x0           # ? NULL terminator
 *          stack[top + 20] <== 0x0           # envp NULL terminator
 *          stack[top + 16] <== 0x0           # argv NULL terminator
 *          stack[top + 12] <== TOP + A3      # argv[3]
 *          stack[top +  8] <== TOP + A2      # argv[2]
 *          stack[top +  4] <== TOP + A1      # argv[1]
 *          stack[top +  0] <== TOP + A0      # argv[0]
 *
 *          where TOP = &stack[top]
 *            and A0 .. A3 are the offsets of the stored arguments from the stack top.
 */

static Boolean setup_arguments(char *args)
{
    /* try to find the top of stack in the target program */
    const CORE_ADDR stack_top = find_label("__stack_top");
    Boolean         done      = FALSE;

    if (stack_top != 0)
    {
        Boolean      target_is_big_endian = (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG);
        char**       argv = buildargv (args);
        char**       argp;
        size_t       string_length = 0;
        unsigned int argc          = 0;
        unsigned int num_pointers;
        unsigned int total_size;
        CORE_ADDR    new_stack_top;

        if (argv == NULL)
            nomem (0);

        /* calculate space required to hold args */

        for (argp = argv; *argp != NULL; argp++)
        {
            string_length += strlen (*argp) + 1;
            argc++;
        }

        DEBUG("%d arguments\n", argc);

        num_pointers = argc + 3;

        total_size = (unsigned int) string_length + num_pointers * BYTES_IN_WORD;

        /* Round up to multiple of 32.  strlen expects memory to come in chunks
           that are at least cache-line (32 bytes) sized.  */
        total_size +=  31;
        total_size &= -32;

        DEBUG("total size: %d\n", total_size);

        new_stack_top = stack_top - total_size;

        DEBUG("new stack top: 0x%08x\n", (unsigned int) new_stack_top);

        /* adjust setting of top of stack in the object code */
        if (set_stack_top(stack_top, new_stack_top))
        {
            CORE_ADDR    data_space = new_stack_top + num_pointers * BYTES_IN_WORD;
            unsigned int i;

            DEBUG("data space: 0x%08x\n", (unsigned int) data_space);

            done = TRUE;

            /* set up the R0 and R1 parameter registers */

            if (!arc_write_jtag_core_register(0, (ARC_Word) argc, TRUE))
                warning(_("can not set parameter register R0 to %d"
                          " - main parameter 'argc' will be undefined"), argc);

            if (!arc_write_jtag_core_register(1, (ARC_Word) new_stack_top, TRUE))
                warning(_("can not set parameter register R1 to %08X"
                          " - main parameter 'argv' will be undefined"), (unsigned int) new_stack_top);

            /* write args onto top of stack */

            for (i = 0; i < argc; i++)
            {
                char*        parameter = argv[i];
                size_t       length    = strlen(parameter) + 1;
                unsigned int bytes     = arc_jtag_ops.memory_write_chunk
                                            ((ARC_Address)  data_space,
                                             (ARC_Byte*)    parameter,
                                             (unsigned int) length);

                if (bytes == (unsigned int) length)
                {
                    DEBUG("written argv[%d] to 0x%08x: \"%s\"\n",
                          i, (unsigned int) data_space, parameter);
                }
                else
                    done = FALSE;

                /* write pointer to argument onto stack */
                if (!write_word(&new_stack_top, (ARC_Word) data_space, target_is_big_endian))
                    done = FALSE;

                data_space += length;
            }

            /* try to write the NULLs */
            if (!write_word(&new_stack_top, 0, target_is_big_endian) ||
                !write_word(&new_stack_top, 0, target_is_big_endian) ||
                !write_word(&new_stack_top, 0, target_is_big_endian))
                done = FALSE;
        }

        freeargv(argv);
    }

    return done;
}


static void restore_stack_top_address(void)
{
    /* if we know the address in the program start-up code at which the stack
     * pointer is set up, it must be because we changed the stack top address
     * in the code - so change it back to the original address as read from the
     * excutable file.
     *
     * This is done so that if the user disconnects from the target, then
     * reconnects to it in a subsequent debugging session but does NOT download
     * the program to the target again (as it is still in target memory), the
     * mechanism for altering the stack top will still work.
     *
     * Note that this has no effect if the target is allowed to resume execution
     * (i.e. a 'detach' is being performed) as we are changing code that has
     * already been executed.
     *
     * 0 is passed as the "old" stack top as it is not used in this situation.
     */
    if (stack_pointer_setup_code_operand_address != 0)
        set_stack_top(0, find_label("__stack_top"));
}


/* -------------------------------------------------------------------------- */
/* 6)                functions for handling Ctrl-C from the user              */
/* -------------------------------------------------------------------------- */

/* The command line interface's stop routine.  This function is installed as a
 * a signal handler for SIGINT (it gets called when the user types Ctrl-C).
 *
 * The first time a user requests a stop, we set the interrupt_processor flag.
 * If this does not work, and the user tries a second time, we ask the user if
 * he'd like to detach from the target.
 */

static void interrupted_by_user(int signo)
{
    /* change the signal handler for Ctrl-C to the second level handler so that
     * if we get the signal again whilst waiting for the program to halt, we do
     * something more drastic
     */
    (void) signal (SIGINT, interrupted_twice);

    /* this flag is checked in each iteration of the loop that polls the target
     * processor to see whether it has halted (e.g. at a breakpoint); if the
     * flag is set, an attempt will be made to force the processor to halt
     *
     * N.B. once the polling loop is running, this flag is set only by this
     *      handler, and is read only by the polling loop - so there is no
     *      mutual exclusion problem to be worried about here; this is a MUCH
     *      cleaner and more reliable method than trying to have this handler
     *      force the halt itself, e.g. by calling target_stop.
     */
    interrupt_processor = TRUE;
}


/* The user typed Ctrl-C twice.  */
static void interrupted_twice(int signo)
{
    if (query(_("Interrupted while waiting for the program to halt.\n"
                "Give up (and stop debugging it)?")))
    {
        struct gdb_exception exception = {RETURN_QUIT,
                                          GDB_NO_ERROR,
                                          _("Interrupted by user")};

        /* put the old signal handler back.  */
        (void) signal (signo, old_signal_handler);

        target_mourn_inferior();
        DEBUG("interrupted_twice: throwing exception\n");
        throw_exception (exception);

        /* control does not return here! */
    }

    /* change the signal handler for Ctrl-C back to the first level handler */
    (void) signal (SIGINT, interrupted_by_user);
}


/* -------------------------------------------------------------------------- */
/* 7)       local functions called from outside this module (from gdb)        */
/* -------------------------------------------------------------------------- */

/* Function: arc_debug_open
 * Parameters :
 * 1. args :
 * 2. from_tty:
 * Returns : void
 * Description:
        1. Connect to the jtag target .
        2. Read the number of action points supported.
        3. Read the configuration of action points.
        4. Set up internal data structures for number of hardware
           breakpoints and watchpoints.
 *
 * The arguments may be:
 *    noreset | <xbf file> 
 */

static void
arc_debug_open (char *args, int from_tty)
{
    /* by default, reset the board, in case it has been left in a funny state by
     * the last connection
     */
    Boolean     reset_required = TRUE;
    char*       xbf_file       = NULL;
    FPGA_Status fpga;

    ENTERARGS("\"%s\" (%d)", (args) ? args : "", from_tty);

    if (args)
    {
        if (strcmp(args, "noreset") == 0)
            reset_required = FALSE;
        else
            xbf_file = args;
    }

    fpga = arc_is_FPGA_configured();

    switch (fpga)
    {
        case INACCESSIBLE:
             /* a warning has already been given */
            return;

        case UNCONFIGURED:
            if (xbf_file == NULL)
            {
                warning(_("target FPGA is not configured; XBF file must be specified"));
                return;
            }
            break;

        case CONFIGURED:
            break;
    }


    /* find the h/w register numbers of various auxiliary registers that we need
     * for debugging
     *
     * N.B. the gdb 'attach' command can attach only to an arcjtag target that
     *      has been created (by this function) within the *same* debugging
     *      session, i.e. the sequence of commands issued by the user is of the
     *      form:
     *                target arcjtag ... detach ... attach
     *
     *      This means that we do not need to worry about finding these numbers
     *      again on an 'attach', as they should be the same (they should really
     *      be the same for *any* target, anyway - we are simply being paranoid
     *      in looking them up, rather than having their numbers hard-coded, in
     *      any case!).
     *
     *      Of course, there are really pathological cases such as the user
     *      blasting the (ARCangel) target with an XBF giving a different
     *      processor configuration, or even physically disconnecting the target
     *      from the host machine and connecting a different target, between
     *      issuing the 'detach' and the 'attach' commands (and that could change
     *      the target's actionpoint configuration, if nothing else!) - but if
     *      the user wants to do that then that is his problem!
     */

    lp_start_regnum = arc_aux_find_register_number("LP_START", ARC_HW_LP_START_REGNUM);
    lp_end_regnum   = arc_aux_find_register_number("LP_END",   ARC_HW_LP_END_REGNUM);
    identity_regnum = arc_aux_find_register_number("IDENTITY", ARC_HW_IDENTITY_REGNUM);
    debug_regnum    = arc_aux_find_register_number("DEBUG",    ARC_HW_DEBUG_REGNUM);
    pc_regnum       = arc_aux_find_register_number("PC",       ARC_HW_PC_REGNUM);
    status32_regnum = arc_aux_find_register_number("STATUS32", ARC_HW_STATUS32_REGNUM);

    icache_ivic_regnum    = arc_aux_find_register_number("IC_IVIC", ARC_HW_IC_IVIC_REGNUM);
    icache_control_regnum = arc_aux_find_register_number("IC_CTRL", ARC_HW_IC_CTRL_REGNUM);
    dcache_ivdc_regnum    = arc_aux_find_register_number("DC_IVDC", ARC_HW_DC_IVDC_REGNUM);
    dcache_control_regnum = arc_aux_find_register_number("DC_CTRL", ARC_HW_DC_CTRL_REGNUM);


    /* just to be sure that it is not in the target stack... */
    (void) unpush_target (&arc_debug_ops);

    if (open_JTAG_interface(from_tty))
    {
        /* if a reset is required, do it now, in case it is necessary to reset
         * the target clock sources to their defaults before trying to access
         * the target's auxiliary registers!
         */
        if (reset_required)
        {
            arc_reset_board();
            arc_jtag_ops.reset_board();
        }

        if (fpga == CONFIGURED)
        {
            /* if we are going to blast the board, don't bother halting the
             * processor first
             */
            if ((xbf_file == NULL) && !halt_processor_on_connection())
            {
                close_JTAG_interface(FALSE);
                return;
            }
        }

        /* if we have been given an XBF file */
        if (xbf_file)
        {
            /* try to blast the board
             * N.B. if the blasting operation fails for any reason,
             *      arc_blast_board calls error and does not return!
             */
            arc_blast_board(xbf_file, from_tty);
        }

        /* N.B. this MUST be done before push_target is called! */
        arc_update_architecture(identity_regnum);

        /* we do not know whether the target processor supports actionpoints until
         * after we have connected to it, as we have to read the AP_BUILD
         * configuration register to find that out.
         */
        (void) arc_initialize_actionpoint_ops(&arc_debug_ops);

        (void) push_target (&arc_debug_ops);

        /* if we blasted the board, we have already checked the architecture -
         * so there is no need to do it again
         */
        if (xbf_file == NULL)
            arc_check_architecture(current_gdbarch,
                                   (current_objfile) ? current_objfile->obfd : NULL);

        if (!reset_required)
        {
            /* if we have been explicitly told NOT to reset the board, it is
             * most likely because we have connected to a target upon which a
             * program is running and we want to debug that program - so assume
             * we have a program ready for execution on the target
             */
            target_mark_running(&arc_debug_ops);

            /* set to_has_execution back to 0; this stops the user getting
             * the
             *
             *    A program is being debugged already.
             *    Are you sure you want to change the file? (y or n) n
             *
             * message on issuing the 'file' command after the connection
             */
            current_target.to_has_execution = 0;
        }

        if (from_tty)
            printf_filtered (_("Connected to the " ARC_TARGET_NAME " target.\n"));
    }
    else
        error(_("Can not connect to target"));
}


static void arc_debug_close(int quitting)
{
    ENTERMSG;
    close_JTAG_interface(FALSE);
}


/* Function: arc_debug_attach
 * Parameters :
 * 1. char *args:
 * 2. int from_tty:
 * Returns : void
 * Description:
 *  1. attach without resetting the board
 */

static void
arc_debug_attach (char *args, int from_tty)
{
    ENTERARGS("\"%s\" (%d)", args, from_tty);

    if (open_JTAG_interface(from_tty))
    {
        /* try to halt the processor (if it is running) */
        if (halt_processor_on_connection())
        {
            arc_check_architecture(current_gdbarch, (current_objfile) ? current_objfile->obfd : NULL);

            if (from_tty)
                printf_filtered (_("Connected to the " ARC_TARGET_NAME " target.\n"));
        }
    }
    else
        error(_("Can not connect to target"));
}


/* Function: arc_debug_detach
 * Parameters :
 * 1. char *x:
 * 2. int i:
 * Returns : void
 * Description:
 *  1. Detach without resetting the board.
 */
static void
arc_debug_detach (char *x, int i)
{
    ENTERMSG;
    close_JTAG_interface(TRUE);
}


/* Function: arc_debug_resume
 * Make the inferior resume execution, sending a signal if necessary.
 * Parameters :
 * 1. ptid_t ptid:
 * 2. int step: 1 - single step, 0 run freely.
 * 3. enum target_signal signal;
 * Returns : void
 * Description:
 *      1. What about pipe-cleaning?
 *      2. Write 0 to the HALT bit in STATUS32.
 *      3. Send a signal (ignore) in this case.
 *      4. if (step) use hardware single step on the ARC700.
 *          done by setting the IS bit in the DEBUG register
 *          and clearing the halt bit in STATUS32.
 */

static void
arc_debug_resume (ptid_t ptid, int step, enum target_signal signal)
{
    ENTERARGS("%d, %d, %d", ptid.pid, step, signal);

    if (signal != TARGET_SIGNAL_0)
        error(_("Signals are not supported by the " ARC_TARGET_NAME " target"));

    /* software breakpoints may have been set/removed, and data in main memory
     * may have been altered, so invalidate (and flush!) the instruction and
     * data caches before restarting!
     *
     * N.B. arc_debug_open disabled the caches, so what is the point of doing this?
     *
     *      Also, invalidating a disabled cache when DC_CTRL.IM = 1 seems to have
     *      the effect of overwriting valid data!!!!!
     */
//  invalidate_caches ();

    /* The DEBUG User bit must be set if breakpoints are to be allowed in user
     * mode. We could set it in target_open, but something (the user?) might clear it.
     * So we set it every time we resume (if stepping, we set the extra bit(s) we
     * need in the DEBUG register in the same operation).
     */

    if (step)
    {
        ARC_RegisterContents mask = 0;

        DEBUG("setting DEBUG.IS bit for single-step\n");

        /* mask for single-stepping differs between ARC600 and ARC700. */
        if (IS_ARC700)
            mask = DEBUG_INSTRUCTION_STEP;
        else
            if (IS_ARC600)
                mask = DEBUG_INSTRUCTION_STEP | DEBUG_SINGLE_STEP;

        /* allow breakpoints in User mode, and set the IS bit in the DEBUG
           register for hardware single instruction stepping. */
        if (!set_debug_user_bit (mask))
            error(_("Can not single-step one instruction"));
    }
    else
    {
        /* allow breakpoints in User mode.  */
        (void) set_debug_user_bit (0);
        start_processor();
    }

    LEAVEMSG;
}


/* Function: arc_debug_wait
 * Parameters :
 * 1. ptid_t ptid:
 * 2. struct target_waitstatus *status: Indicates status at end of wait
 * Returns : ptid
 * Description:
 *        Poll status32 for the value of H bit.
 *        After H bit is set in status32.
 *        Wait till LD (load pending bit) in the DEBUG register is cleared.
 *        SH bit is set if flag instruction was used to halt the processor.
 *        BH bit is set if the processor stopped due to a brk_s
 *        instruction. Set the target_waitstatus (signal) to SIGTRAP
 *        only in such a situation.
 */

static ptid_t
arc_debug_wait (ptid_t ptid, struct target_waitstatus *status)
{
    ENTERMSG;

    /* this flag will be set if the user types Ctrl-C */
    interrupt_processor = FALSE;

    /* set up signal handler for Ctrl-C */
    old_signal_handler = signal (SIGINT, interrupted_by_user);

    wait_for_processor_to_halt(status);

    /* put the old signal handler back */
    (void) signal (SIGINT, old_signal_handler);

    if (status->kind == TARGET_WAITKIND_EXITED)
        target_mark_exited (&arc_debug_ops);

    /* inform the actionpoints module that the target has halted */
    arc_target_halted();

    /* Bug #1311 (ARC600): Setting a breakpoint on the last instruction of a
     * ZOL causes GDB to stop at LP_START.  Detect this condition and warn the
     * user.
     */
    if (IS_ARC600)
    {
        ARC_RegisterContents pc, lp_start, lp_end, lp_count;

        if (arc_read_jtag_core_register(ARC_LP_COUNT_REGNUM, &lp_count, TRUE) && (lp_count != 0)  &&
            arc_read_jtag_aux_register (pc_regnum,           &pc,       TRUE)                     &&
            arc_read_jtag_aux_register (lp_start_regnum,     &lp_start, TRUE) && (pc == lp_start) &&
            arc_read_jtag_aux_register (lp_end_regnum,       &lp_end,   TRUE))
        {
            struct breakpoint *b;

            for (b = breakpoint_chain; b != NULL; b = b->next)
            {
                /* lp_end is the address of the last instruction + the size of
                 * the last instruction.  We could use the disassembler and find
                 * out the size, but it's easier just to try both possible sizes.
                 */
                if ((b->enable_state == bp_enabled) &&
                    (b->loc->address == lp_end - 4 || b->loc->address == lp_end - 2))
                {
                    warning(_("did you set a breakpoint on the last instruction of a"
                              "Zero Overhead Loop? Such breakpoints do not work properly."));
                }
            }
        }
    }

    return inferior_ptid;
}


/* Function: arc_debug_fetch_registers.
 *
 * Parameters :
 *    1  regcache : cache to write register to
 *    2. int gdb_regno: Register number (-1 means all registers)
 * Returns : void
 */
static void
arc_debug_fetch_registers (struct regcache *regcache, int gdb_regno)
{
    ENTERARGS("%d", gdb_regno);

    /* all registers */
    if (gdb_regno == -1)
    {
        int num_core_registers = (int) arc_core_register_count(get_regcache_arch(regcache));

        /* core registers */
        for (gdb_regno = 0; gdb_regno < num_core_registers; gdb_regno++)
            debug_fetch_one_register(regcache, (ARC_RegisterNumber) gdb_regno, gdb_regno);

        /* aux registers (incl. build configuration registers) */
        arc_all_aux_registers(debug_fetch_reg, regcache);
    }
    else
    {
        ARC_RegisterNumber hw_regno = get_hw_regnum_mapping (gdb_regno);

        if (hw_regno == INVALID_REGISTER_NUMBER)
            error(_("Invalid register number: %d"), gdb_regno);
        else
            debug_fetch_one_register(regcache, hw_regno, gdb_regno);
    }

    LEAVEMSG;
}


/* Function: arc_debug_store_registers.
 *
 * Parameters :
 *    1  regcache : cache to read register from
 *    2. int gdb_regno: register number (-1 means all registers)
 * Returns : void
 */
static void
arc_debug_store_registers (struct regcache *regcache, int gdb_regno)
{
    ENTERARGS("%d", gdb_regno);

    /* all registers */
    if (gdb_regno == -1)
    {
        int num_core_registers = (int) arc_core_register_count(get_regcache_arch(regcache));

        /* core registers */
        for (gdb_regno = 0; gdb_regno < num_core_registers; gdb_regno++)
            debug_store_one_register(regcache, (ARC_RegisterNumber) gdb_regno, gdb_regno);

        /* aux registers (excl. build configuration registers, which are not writable) */
        arc_all_aux_registers(debug_store_reg, regcache);
    }
    else
    {
        ARC_RegisterNumber hw_regno = get_hw_regnum_mapping (gdb_regno);

        if (hw_regno == INVALID_REGISTER_NUMBER)
            error(_("Invalid register number: %d"), gdb_regno);
        else
            debug_store_one_register(regcache, hw_regno, gdb_regno);
    }

    LEAVEMSG;
}


/* Function: arc_debug_prepare_to_store.
 * Returns : void
 * Description:
 *          Use deprecated register information for this.
 */

/* This gets called just before store_regs */
static void
arc_debug_prepare_to_store (struct regcache *regcache)
{
    ENTERMSG;
}


/* Read or write memory
 *
 *   if 'object' is TARGET_OBJECT_MEMORY then
 *       if 'writebuf' is NULL
 *           read 'len' bytes of data from target memory starting at address 'offset' to 'readbuf'
 *       else
 *           write 'len' bytes of data from 'writebuf' to target memory starting at address 'offset'
 *
 *    returns number of bytes of memory read/written
 */

static LONGEST
arc_debug_xfer_partial (struct target_ops *ops,        // unused
                        enum target_object object,
                        const char        *annex,      // unused
                        gdb_byte          *readbuf,
                        const gdb_byte    *writebuf,
                        ULONGEST           offset,
                        LONGEST            len)
{
    ENTERARGS("object %d offset 0x%x len %lld", (unsigned int) object, (unsigned int) offset, len);

    /* Handle memory */
    if (object == TARGET_OBJECT_MEMORY)
    {
        unsigned int xfered;

        /* Get out of user mode so that we can read/write anything anywhere.  */
        arc_change_status32(CLEAR_USER_BIT);

        /* No need to worry about the alignment of the address 'offset' - the
         * JTAG memory read/write operations handle that.
         */
        if (writebuf != NULL)
        {
            xfered = arc_jtag_ops.memory_write_chunk
                         ((ARC_Address)  offset,
                          (ARC_Byte*)    writebuf,
                          (unsigned int) len);

            DEBUG("...leaving %s(memory write) with return value %u\n",
                  __FUNCTION__, xfered);
        }
        else /* read data */
        {
            xfered = arc_jtag_ops.memory_read_chunk
                         ((ARC_Address)  offset,
                          (ARC_Byte*)    readbuf,
                          (unsigned int) len);

            DEBUG("...leaving %s(memory read) with return value %u\n",
                  __FUNCTION__, xfered);
        }

        arc_change_status32(RESTORE_USER_BIT);

        return (LONGEST) xfered;
    }

    if (object == TARGET_OBJECT_AVAILABLE_FEATURES)
    {
        /* we should create and return an XML string here */
        return -1;
    }

    printf_filtered(_("\nRequested target_object %d not yet supported with " ARC_TARGET_NAME "\n"), (int) object);
    return -1;
}


static void
arc_debug_files_info (struct target_ops *target)
{
    /* Do nothing. Just say it's a remote target */
    ENTERMSG;
}


/* Function: arc_debug_insert_breakpoint
 * Parameters :
 * 1. bpt: information defining breakpoint.
 * Returns : int - 0 for success.
 * Description:
 */

static int arc_debug_insert_breakpoint (struct bp_target_info* bpt)
{
    const unsigned char *breakpt_instruction;
    unsigned int         bytes;

    ENTERARGS("0x%08X", (unsigned int) bpt->placed_address);

    breakpt_instruction = gdbarch_breakpoint_from_pc (current_gdbarch,
                                                      &bpt->placed_address,
                                                      &bpt->placed_size);

    /* FIXME: alignment of breakpt_instruction! */
    DEBUG("breakpoint size = %d and breakpoint instruction = 0x%x\n",
          bpt->placed_size, *(unsigned int *) breakpt_instruction);

    /* save the existing instruction at the given address */
    bytes = arc_jtag_ops.memory_read_chunk
                ((ARC_Address)  bpt->placed_address,
                 (ARC_Byte*)    bpt->shadow_contents,
                 (unsigned int) bpt->placed_size);

    if (bytes == (unsigned int) bpt->placed_size)
        /* overwrite the instruction with the breakpoint instruction */
        bytes = arc_jtag_ops.memory_write_chunk
                    ((ARC_Address)  bpt->placed_address,
                     (ARC_Byte*)    breakpt_instruction,
                     (unsigned int) bpt->placed_size);

    return (bytes == (unsigned int) bpt->placed_size) ? 0 : 1;
}


/* Function: arc_debug_remove_breakpoint.
 * Parameters :
 * 1. bpt: information defining breakpoint.
 * Returns : int - 0 for success.
 * Description:
 *  Write the old contents back for the breakpoint.
 */

static int arc_debug_remove_breakpoint (struct bp_target_info* bpt)
{
    unsigned int bytes;

    /* FIXME: alignment of shadow_contents! */
    ENTERARGS("0x%08X, 0x%lx", (unsigned int)     bpt->placed_address,
                               *(unsigned long *) bpt->shadow_contents);

    /* write the old code back */
    bytes = arc_jtag_ops.memory_write_chunk
                ((ARC_Address)  bpt->placed_address,
                 (ARC_Byte*)    bpt->shadow_contents,
                 (unsigned int) bpt->placed_size);

    return (bytes == (unsigned int) bpt->placed_size) ? 0 : 1;
}


/* Function: arc_debug_kill
 * Parameters : void.

 * Returns : void.
 * Description: Heavy duty arsenal. Kill the process.
 * Maybe we do a board reset and kill it. Write 1 to Halt in Status32.
 */

static void
arc_debug_kill (void)
{
  ENTERMSG;

  target_mourn_inferior ();
}


/* Function: arc_debug_load
 * Parameters :
 * 1. char * args: Arguments.
 * 2. int from_tty: Which terminal.
 * Returns : void.
 * Description: Load the program into memory via the JTAG interface.
 */

static void
arc_debug_load (char *args, int from_tty)
{
    /* Write to RAM on the board by running through the sections .*/
    asection* bss_section;

    ENTERARGS("%s", args);

    if (exec_bfd == NULL)
        error(_("Must use 'file' command before 'load' command"));

    arc_aux_check_pc_defined(NULL);

    arc_check_architecture(current_gdbarch, exec_bfd);

    /* in case anything was previously loaded */
    arc_set_jtag_interception(INTERCEPTION_RESET);

    generic_load(args, from_tty);

    /* Zero the BSS, if it exists.  */
    bss_section = bfd_get_section_by_name (exec_bfd, ".bss");

    if (bss_section)
    {
        CORE_ADDR     bss_addr = bfd_section_lma (exec_bfd, bss_section);
        bfd_size_type bss_size = bfd_get_section_size (bss_section);
        unsigned int  bytes;

        printf_filtered(_("Zeroing section .bss, size 0x%0x lma 0x%0x\n"),
                        (unsigned int) bss_size, (unsigned int) bss_addr);

        bytes = arc_jtag_ops.memory_zero_fill((ARC_Address)  bss_addr,
                                               (unsigned int) bss_size);
        if (bytes != (unsigned int) bss_size)
            warning(_("load: error zeroing BSS section - only %u bytes zeroed"), bytes);
    }
    else
    {
        DEBUG("%s: no BSS section\n", __FUNCTION__);
    }

    /* we do not yet know the address in the program code at which the program's
     * stack pointer is set up
     */
    stack_pointer_setup_code_operand_address = 0;

    /* we now have a program ready for execution on the target */
    target_mark_running(&arc_debug_ops);
}


/* Function: arc_debug_create_inferior
 * Parameters :
 * 1. char * exec_file:
 * 2. char * args:
 * 3. char ** env;
 * Returns : void.
 * Description: Set up sanity values for arc_debug_create_inferior. More thought
 * needed for this.
 */

static void
arc_debug_create_inferior (char *exec_file, char *args, char **env, int dummy)
{
    Boolean set_no_args = TRUE;
    char*   all_args    = NULL;

    ENTERARGS("exec_file = \"%s\", args = \"%s\"", exec_file, args);

    /* If no exec file handed to us, get it from the exec-file command
       -- with a good, common error message if none is specified.  */
    if (exec_file == NULL)
        exec_file = get_exec_file (1);

    /* include the exec file name as arg[0] */
    if (exec_file != NULL || args != NULL)
    {
        size_t length = 10;    /* safty margin */

        if (exec_file != NULL)
            length += strlen(exec_file) + 1;

        if (args != NULL)
            length += strlen(args) + 1;

        all_args = xmalloc(length);

        all_args[0] = '\0';

        if (exec_file != NULL)
            (void) strcat(all_args, exec_file);

        if (args != NULL)
        {
            (void) strcat(all_args, " ");
            (void) strcat(all_args, args);
        }
    }

    arc_aux_check_pc_defined(NULL);

    /* We don't really have a PID or anything, but GDB uses this value to check
       if the program is running. */
    inferior_ptid.pid = 42;

    DEBUG("setting PC to 0x%x\n", (unsigned int) bfd_get_start_address (exec_bfd));

    /* must set the PC to the start address */
    write_pc (bfd_get_start_address (exec_bfd));

    target_mark_running(&arc_debug_ops);

    if (all_args != NULL)
    {
        if (setup_arguments(all_args))
            set_no_args = FALSE;
        else
            warning(_("can not set up arguments to program"));

        xfree(all_args);
    }

    /* if there are no arguments to be passed to the program, or we failed to
     * set them up, at least try to set R0 and R1 to indicate that are no
     * arguments!
     */
    if (set_no_args)
    {
        if (!arc_write_jtag_core_register(0, 0, TRUE))
            warning(_("can not set parameter register R0 to 0 - main parameter 'argc' will be undefined"));

        if (!arc_write_jtag_core_register(1, 0, TRUE))
            warning(_("can not set parameter register R1 to 0 - main parameter 'argv' will be undefined"));
    }

    arc_set_jtag_interception(INTERCEPTION_ON);

    /* Why are the caches disabled anyway? Particularly as arc_debug_resume
     * invalidates them before each restart?
     */
   disable_caches();
}


/* Function: arc_debug_mourn_inferior
 * Parameters :void.
 * Returns : void.
 * Description: Set up sanity values for arc_debug_create_inferior.
 *              More thought needed for this.
 */

static void
arc_debug_mourn_inferior (void)
{
    ENTERMSG;

//  (void) unpush_target (&arc_debug_ops);
    generic_mourn_inferior ();
}


/* Function: arc_debug_thread_alive
 * Parameters :ptid_t ptid.
 * Returns : 1 always.
 * Description:
 */

static int
arc_debug_thread_alive (ptid_t ptid)
{
    ENTERMSG;
    return 1;
}


/* Function: arc_debug_can_run
 * Parameters : none
 * Returns : 1 if our target is runnable
 * Description: Mark our target-struct as eligible for stray "run" and "attach" commands.
 */

static int arc_debug_can_run (void)
{
    /* if we are connected to the JTAG i/f, and a program is loaded */
    return (arc_jtag_ops.status == JTAG_OPENED) && current_target.to_has_execution;
}


/* we do not support asynchronous execution of the target program (i.e. commands
 * like 'run' or 'continue' or 'step' can not be executed in background mode
 * by appending a '&' to them) so we do not need to implement the target stop
 * operation (called by the 'interrupt' command); interrupting a running program
 * is handled by the Ctrl-C mechanism
 */

#if 0
/* Function: arc_debug_stop
 * Parameters: void
 * Returns: void.
 * Description: Stop the Processor. 
 */
static void
arc_debug_stop (void)
{
    ENTERMSG;
    interrupt_processor = TRUE;
}
#endif


/* -------------------------------------------------------------------------- */
/* 8)                   helper routines for added commands                    */
/* -------------------------------------------------------------------------- */

/* Print Processor Variant Info.  */
static void
arc_print_processor_variant_info (char* arg, int from_tty)
{
    printf_filtered(_("%s\n"), arc_version_image(arc_get_architecture(identity_regnum)));
}


static void
arc_debug_jtag_reset_board (char* arg, int from_tty)
{
    /* make sure the GPIO interface is open */
    if (gpio_open())
    {
        printf_filtered(_("Attempting to reset target board...\n"));

        if (arc_jtag_ops.status == JTAG_OPENED)
        {
            /* try to force the processor to halt */
            stop_processor();
        }

        /* try to reset the board */
        arc_reset_board();
        arc_jtag_ops.reset_board();

        if (arc_jtag_ops.status == JTAG_OPENED)
        {
            /* the ARC actionpoint registers are cleared upon reset, so it is
             * necessary to restore any actionpoints that were set
             */
            if (!arc_restore_actionpoints_after_reset())
                warning(_("can not restore hardware actionpoints"));
        }
    }
}


static void
arc_list_actionpoints (char* arg, int from_tty)
{
    /* gdb manages breakpoints by deleting them from the target as soon as it
     * has halted, then re-inserting them again immediately before execution is
     * resumed (no, I don't know why either, unless it is to make generating a
     * disassembly display easier by removing all the s/w b/ps from the code) -
     * so in order to display what actionpoints are currently in use, we must
     * temporarily re-insert the breakpoints!
     */
    insert_breakpoints();
    arc_display_actionpoints();
    (void) remove_breakpoints();
}


/* -------------------------------------------------------------------------- */
/* 9)                           initialization functions                      */
/* -------------------------------------------------------------------------- */

/* Function: initialize_arc_debug_ops
 * Parameters: void
 * Returns: void.
 * Description: Initialize the jtag target operations.
 */

static void
initialize_arc_debug_ops (void)
{
    ENTERMSG;

    arc_debug_ops.to_shortname = ARC_TARGET_NAME;
    arc_debug_ops.to_longname  = "Remote JTAG debug target (ARC Processors)";
    arc_debug_ops.to_doc       = "Remote JTAG debug target (ARC Processors)";

    arc_debug_ops.to_open   = arc_debug_open;
    arc_debug_ops.to_close  = arc_debug_close;
    arc_debug_ops.to_attach = arc_debug_attach;
    arc_debug_ops.to_detach = arc_debug_detach;
    arc_debug_ops.to_resume = arc_debug_resume;
    arc_debug_ops.to_wait   = arc_debug_wait;

    arc_debug_ops.to_fetch_registers  = arc_debug_fetch_registers;
    arc_debug_ops.to_store_registers  = arc_debug_store_registers;
    arc_debug_ops.to_prepare_to_store = arc_debug_prepare_to_store;
    arc_debug_ops.to_xfer_partial     = arc_debug_xfer_partial;
    arc_debug_ops.to_files_info       = arc_debug_files_info;

    arc_debug_ops.to_insert_breakpoint = arc_debug_insert_breakpoint;
    arc_debug_ops.to_remove_breakpoint = arc_debug_remove_breakpoint;

    arc_debug_ops.to_kill = arc_debug_kill;
    arc_debug_ops.to_load = arc_debug_load;

    arc_debug_ops.to_create_inferior   = arc_debug_create_inferior;
    arc_debug_ops.to_mourn_inferior    = arc_debug_mourn_inferior;
    arc_debug_ops.to_thread_alive      = arc_debug_thread_alive;
//  arc_debug_ops.to_stop              = arc_debug_stop;
    arc_debug_ops.to_can_run           = arc_debug_can_run;
    arc_debug_ops.to_terminal_inferior = NULL;

    arc_debug_ops.to_stratum = process_stratum;

    arc_debug_ops.to_has_all_memory = 1;
    arc_debug_ops.to_has_memory     = 1;
    arc_debug_ops.to_has_stack      = 0;  /* defer setting this until the program has been loaded */
    arc_debug_ops.to_has_registers  = 1;
    arc_debug_ops.to_has_execution  = 0;  /* defer setting this until the program has been loaded */

    arc_debug_ops.to_magic = OPS_MAGIC;
}


/* -------------------------------------------------------------------------- */
/*                               externally visible functions                 */
/* -------------------------------------------------------------------------- */

void
_initialize_arc_debug (void)
{
    ENTERMSG;

    initialize_arc_debug_ops ();
    add_target (&arc_debug_ops);

    /* register ARC-specific commands with gdb */

    add_setshow_boolean_cmd(ARC_FSM_DEBUG_COMMAND,
                            no_class,
                            &arc_jtag_ops.state_machine_debug,
                            _("Set whether to print JTAG state machine debug messages.\n"),
                            _("Show whether to print JTAG state machine debug messages.\n"),
                            _("If set the JTAG state machine messages are printed.\n"),
                            NULL,
                            NULL,
                            &setlist,
                            &showlist);

    add_setshow_uinteger_cmd(ARC_JTAG_RETRY_COMMAND,
                             no_class,
                             &arc_jtag_ops.retry_count,
                             _("Set the number of attempts to be made for a JTAG operation.\n"),
                             _("Show the number of attempts to be made for a JTAG operation.\n"),
                             _("Indicates the number of times a JTAG operation is attempted before returning a failure.\n"),
                             NULL,
                             NULL,
                             &setlist,
                             &showlist);

    (void) add_cmd(ARC_CONFIGURATION_COMMAND,
                   class_info,
                   arc_print_processor_variant_info,
                   _("Show ARC configuration information.\n"
                     ARC_CONFIGURATION_COMMAND_USAGE),
                   &infolist);

    (void) add_cmd(ARC_RESET_BOARD_COMMAND,
                   class_obscure,
                   arc_debug_jtag_reset_board,
                   _("Reset the board.\n"
                     ARC_RESET_BOARD_COMMAND_USAGE),
                   &cmdlist);

    (void) add_cmd(ARC_LIST_ACTIONPOINTS_COMMAND,
                   class_obscure,
                   arc_list_actionpoints,
                   _("List the processor actionpoints.\n"
                     ARC_LIST_ACTIONPOINTS_COMMAND_USAGE),
                   &cmdlist);
}


void arc_change_status32(ARC_Status32Action action)
{
    static ARC_RegisterContents status32;

    if (action == CLEAR_USER_BIT)
    {
        /* Get processor out of user mode. */

        if (arc_read_jtag_aux_register(status32_regnum, &status32, FALSE))
        {
            /* if the User bit is actually set */
            if (status32 & STATUS32_USER)
                if (!arc_write_jtag_aux_register(status32_regnum,
                                                 status32 & ~STATUS32_USER, FALSE))
                    warning(_("can not clear User bit in STATUS32 auxiliary register"));
        }
        else
            warning(_("can not read STATUS32 auxiliary register"));
    }
    else
    {
        /* if the User bit was actually cleared */ 
        if (status32 & STATUS32_USER)
            if (!arc_write_jtag_aux_register(status32_regnum, status32, FALSE))
                warning(_("can not restore User bit in STATUS32 auxiliary register"));
    }
}


Boolean arc_read_jtag_core_register(ARC_RegisterNumber    hw_regno,
                                    ARC_RegisterContents* contents,
                                    Boolean               warn_on_failure)
{
    if (arc_jtag_ops.read_core_reg(hw_regno, contents) == JTAG_SUCCESS)
    {
        DEBUG("Read value 0x%08X from register %d\n", *contents, hw_regno);
        return TRUE;
    }

    if (warn_on_failure)
        core_warning(_("failure reading %score register %s"),
                     hw_regno, 
                     arc_core_register_gdb_number(hw_regno));
    return FALSE;
}


Boolean arc_write_jtag_core_register(ARC_RegisterNumber   hw_regno,
                                     ARC_RegisterContents contents,
                                     Boolean              warn_on_failure)
{
    if (arc_jtag_ops.write_core_reg(hw_regno, contents) == JTAG_SUCCESS)
    {
        DEBUG("Written value 0x%08X to register %d\n", contents, hw_regno);
        return TRUE;
    }

    if (warn_on_failure)
        core_warning(_("failure writing to %score register %s"),
                     hw_regno, 
                     arc_core_register_gdb_number(hw_regno));
    return FALSE;
}


Boolean arc_read_jtag_aux_register(ARC_RegisterNumber    hw_regno,
                                   ARC_RegisterContents* contents,
                                   Boolean               warn_on_failure)
{
    if (arc_jtag_ops.read_aux_reg(hw_regno, contents) == JTAG_SUCCESS)
    {
        DEBUG("Read value 0x%08X from register %d\n", *contents, hw_regno);
        return TRUE;
    }

    if (warn_on_failure)
        aux_warning(_("failure reading auxiliary register %s (0x%x)"),
                    hw_regno);
    return FALSE;
}


Boolean arc_write_jtag_aux_register(ARC_RegisterNumber   hw_regno,
                                    ARC_RegisterContents contents,
                                    Boolean              warn_on_failure)
{
    ARC_AuxRegisterDefinition* def = arc_find_aux_register_by_hw_number(hw_regno);

    contents = arc_write_value(def, contents);

    if (arc_jtag_ops.write_aux_reg(hw_regno, contents) == JTAG_SUCCESS)
    {
        DEBUG("Written value 0x%08X to register %d\n", contents, hw_regno);
        return TRUE;
    }

    if (warn_on_failure)
        aux_warning(_("failure writing to auxiliary register %s (0x%x)"),
                    hw_regno);
    return FALSE;
}

/******************************************************************************/
